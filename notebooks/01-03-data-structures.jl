# Data Structures ## Lists / ArraysYou've already seen these. These are mutable, ordered collections and are called **Arrays** in Julia.collection = [1, 2, 4, 5] collection = [1, 2, 4, 5.0]    # notice the data type collection = [1, 2, 4, 5//3, 5.7]  # rationals will get translated to floats here collection = [1, 2, 4, "5"]   collection = [1, 2, 4, 5]append!(collection, 60)     # functions with a bang (!) at the end mutate the passed object collectioncollection = [1, 2, 4, 5]collection[0]      # !! Important! collection[1]      # julia uses ... collection = [10, 20, 30, 40, 50, 60, 70, 80, 90]collection[1:5]   # this is different from python!collection[5:end]   # doesn't work if you omit the `end` collection[:]       # this works though (creates a copy )collection[:4]     # this is different! It's just 4  collection[1:4]collection[-1]     # also bad collection[end-1]  # different from python again! All of these are pretty easy to get used to. You won't have much trouble with this after a while. Don't worry about them too much.  ### Mutationcollection[1] = 99@show collection;       # we'll need this show macro below   copy_of_collection = collection copy_of_collection[1] = 100 
copy_of_collectioncollectionsecond_copy = copy(collection)second_copy[1] = 9999           
@show second_copy          
@show collection
@show copy_of_collection;# there's also the issue of deepcopy but we'll leave that for more advanced videos ## Tuples Similar to arrays but immutable. collection = (1, 2, 4) languages = ("julia", "python", "c", "java")languages[1]languages[1] = "Go"languages### Named Tuples tools = (language ="julia", ide="pluto", explorer="perseverence")tools[1]tools.language## Dictionaries d = Dict("language" =>  "julia", "ide"  => "pluto") d["language"]d.language   # that doesn't workd["explorer"] = "perseverence"@show d;pop!(d)      # bang functions "mutate" objects (by convention)@show d;# can merge two dictionaries 
e = Dict("os" => "arch", "language" => "java")merge!(d, e)      # duplicated keys in e override those in d @show d;
@show e;for (k, v) in d           # parens are necessary 
    println("key=$k  \t  val=$v")
end ### Using Symbols as Keyssimple = Dict(:lang => "julia", 
          :ide => "pluto")simple[:lang]     # this is slightly faster and more memory efficient for (k, v) in simple   # rest of it is the same
    println(k)
end